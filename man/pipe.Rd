% Generated by roxygen2 (4.0.2): do not edit by hand
\name{\%>\%}
\alias{\%>\%}
\title{magrittr forward-pipe operator}
\usage{
lhs \%>\% rhs
}
\arguments{
\item{lhs}{A value or the magrittr placeholder.}

\item{rhs}{A function call using the magrittr semantics.}
}
\description{
Pipe an object forward into a function or call expression.
}
\details{
\bold{Using \code{\%>\%} with unary function calls}\cr
When functions require only one argument, \code{x \%>\% f} is equivalent
to \code{f(x)} (not exactly equivalent; see technical note below.)
\cr\cr
\bold{Placing lhs as the first argument in rhs call}\cr
The default behavior of \code{\%>\%} when multiple arguments are required
in the rhs call, is to place lhs as the first argument, i.e.
\code{x \%>\% f(y)} is equivalent to \code{f(x, y)}.
\cr\cr
\bold{Placing lhs elsewhere in rhs call}\cr
Often you will want lhs to the rhs call at another position than the first.
For this purpose you can use the dot (\code{.}) as placeholder. For example,
\code{y \%>\% f(x, .)} is equivalent to \code{f(x, y)} and
\code{z \%>\% f(x, y, arg = .)} is equivalent to \code{f(x, y, arg = z)}.
\cr\cr
\bold{Using the dot for secondary purposes}\cr
Othen, some attribute or property of lhs is desired in the rhs call in
addition to the value of lhs itself, e.g. the number of rows or columns.
It is perfectly valid to use the dot placeholder several times in the rhs
call, but by design the behaviour is slightly different when using it inside
nested function calls. In particular, if the placeholder is only used
in a nested function call, lhs will also be placed as the first argument!
The reason for this is that in most use-cases this produces the most readable
code. For example, \code{iris \%>\% subset(1:nrow(.) \%\% 2 == 0)} is
equivalent to \code{iris \%>\% subset(., 1:nrow(.) \%\% 2 == 0)} but
slightly more compact. It is possible to overrule this behavior by enclosing
the rhs in braces. For example, \code{1:10 \%>\% {c(min(.), max(.))}} is
equivalent to \code{c(min(1:10), max(1:10))}.
\cr\cr
\bold{Using \%>\% with call- or function-producing rhs}\cr
It is possible to force evaluation of rhs before the piping of lhs takes
place. This is useful when rhs produces the relevant call or function.
To evaluate rhs first, enclose it in parentheses, i.e.
\code{a \%>\% (function(x) x^2)}, and \code{1:10 \%>\% (call("sum"))}.
\cr\cr
\bold{Using lambda expressions with \code{\%>\%}}\cr
More advanced functions/lambdas can be created on the fly by using braces to
enclose the function expression. Inside, the dot will represent the function
input (typically lhs), but it can be renamed by having a bare symbol as the
very first expression. See also the examples section.
\cr\cr
\bold{Using the dot-place holder as lhs}\cr
When the dot is used as lhs, the result will be a functional sequence,
i.e. a function which applies the entire chain of right-hand sides in turn
to its input. See the examples.
}
\section{Technical notes}{

The magrittr pipe operators use non-standard evaluation. They capture
their inputs and examines them to figure out how to proceed. First a function
is produced from all of the individual right-hand side expressions, and
then the result is obtained by applying this function to the left-hand side.
For most purposes, one can disregard the subtle aspects of magrittr's
evaluation, but some functions may capture their calling environment,
and thus using the operators will not be exactly equivalent to the
"standard call" without pipe-operators.
\cr\cr
Another note is that spectial attention is advised when using non-magrittr
operators in a pipe-chain, as operator precedence will impact how the
chain is evaluated. In general it is advised to use the aliases provided
by magrittr.
}
\examples{
# Basic use:
iris \%>\% head

# Use with lhs as first argument
iris \%>\% head(10)

# Using the dot place-holder
"Ceci n'est pas une pipe" \%>\% gsub("une", "un", .)

# When dot is nested, lhs is still placed first:
sample(1:10) \%>\% paste0(LETTERS[.])

# This can be avoided:
rnorm(100) \%>\% {c(min(.), mean(.), max(.))} \%>\% floor

# Lambda expressions:
iris \%>\%
{
  size <- sample(1:10, size = 1)
  rbind(head(., size), tail(., size))
}

# renaming in lambdas:
iris \%>\%
{
  my_data # This will be the name
  size <- sample(1:10, size = 1)
  rbind(head(my_data, size), tail(my_data, size))
}

# Building unary functions with \%>\%
trig_fest <- . \%>\% tan \%>\% cos \%>\% sin

1:10 \%>\% trig_fest
}
\seealso{
\code{\link{\%<>\%}}, \code{\link{\%T>\%}}, \code{\link{\%$\%}}
}

