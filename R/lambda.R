#' Shorthand notation for anonymous/lambda functions
#' in magrittr pipelines.
#'
#' It is suggested to use this for anonymous functions when composing chains
#' with magrittr. It is shorter and has a signature designed for the purpose
#' (i.e. it takes a value as the first argument to be fed into the function),
#' and it avoids the high precedence of the \code{function} keyword.
#'
#' \code{lambda} has a special syntax, where the expression is defined as
#' \code{symbol -> expression}. The alias \code{l} is shorthand for \code{lambda}.
#' If both \code{value} and \code{expr} is provided, the resulting function
#' is evaluated with \code{value} as input; otherwise the function is returned.
#' Here the argument \code{value} will used as \code{expr}.
#'
#' @param value the value to be fed into the function. If this is the only
#'   argument provided, it is taken to be the function expression, see details.
#' @param expr A special kind of expression for the anonymous function.
#'   The syntax is \code{symbol -> expression}, see the examples. If both
#'   arguments are supplied, the lambda generated by \code{expr} is immediately
#'   called with \code{value}, making it easy to use in chains.
#' @return If called with one argument, a new anonymous function. If called
#'   with two argumetns, the result of evaluating the function.
#' @rdname lambda
#' @export
#' @examples
#' lambda(x -> x^2 + 2*x)
#'
#' sapply(1:10, lambda(x -> x^2))
#'
#' Filter(lambda(x -> x > 0), rnorm(100))
#'
#' iris %>%
#'   lambda(dfr -> rbind(dfr %>% head, dfr %>% tail))
#'
#' 1:10 %>%
#'   sin %>%
#'   lambda(x -> {
#'     d <- abs(x) > 0.5
#'     x*d
#'   })
lambda <- function(value, expr)
{

  call <- missing(expr)
  expr <- if (call) substitute(value) else substitute(expr)

  if (!is.call(expr) || !identical(expr[[1]], quote(`<-`))) {
    stop("Malformed expression. Expected format is symbol -> expression.",
      call. = FALSE)
  }
  if (!is.symbol(expr[[3]])) {
    stop("Malformed expression. Expecting one variable name on LHS",
      call. = FALSE)
  }

  # Construct the function
  arg_name <- as.character(expr[[3]])
  args <- setNames(list(quote(expr = )), arg_name)
  body <- expr[[2]]

  fun <- eval(call("function", as.pairlist(args), body), parent.frame())

  if (call) fun else fun(value)
}

#' @rdname lambda
#' @export
l <- lambda
